import cv2
import numpy as np

def get_contour_areas(contours):
    # returns the areas of all contours as list
    all_areas = []
    for cnt in contours:
        area = cv2.contourArea(cnt)
        all_areas.append(area)
    return all_areas

def get_dimensions(imagetoconvert,rect):
    (tl, tr, br, bl) = rect
    #distance between two points is root((x1-x2^2) + (y1-y2^2))
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    maxWidth = max(int(widthA), int(widthB))
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))    
    dst = np.array([
        [0, 0],
        [maxWidth - 1, 0],
        [maxWidth - 1, maxHeight - 1],
        [0, maxHeight - 1]], dtype = "float32")
    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(imagetoconvert, M, (maxWidth, maxHeight))
    return warped

#original --> scale --> gray --> thresh --> blur -->errode + dilate -->edge detection
original_image= cv2.imread('C:\\Users\\test\\Desktop\\Radio.png')
image_scaled = cv2.resize(original_image, (900, 400), interpolation = cv2.INTER_AREA)
image_scaled2 = image_scaled.copy()
image_scaled3 = image_scaled.copy()
gray = cv2.cvtColor(image_scaled,cv2.COLOR_BGR2GRAY)
cv2.imshow('ORG1',gray)
ret,thresh = cv2.threshold(gray, 10,255, cv2.THRESH_BINARY)
blured_gray = cv2.bilateralFilter(thresh, 5, 150, 250)
kernel = np.ones((5,5), np.uint8)
erosion = cv2.erode(blured_gray, kernel, iterations = 1)
dilated = cv2.dilate(erosion, kernel, iterations = 1)
edged = cv2.Canny(dilated, 5, 250)

#detect broken contours and draw them --> do the whole process again
contours, hierarchy = cv2.findContours(edged, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
cv2.drawContours(image_scaled,contours,-1,(0,0,255), 7)
cv2.imshow('ORG1',image_scaled)

#img-->gray-->contour img -->edge detection -->contour
gray2 = cv2.cvtColor(image_scaled,cv2.COLOR_BGR2GRAY)
edged2 = cv2.Canny(gray2, 5, 250)
contours2, hierarchy = cv2.findContours(edged2, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

#sort this new contours
sorted_contours = sorted(contours2, key=cv2.contourArea, reverse=True)
cv2.drawContours(image_scaled2,sorted_contours,0,(0,255,0), 3)
c=sorted_contours[0]

#get persective
approx = cv2.approxPolyDP(c, 0.01*cv2.arcLength(c,True),True)
p1x = approx[0][0][0]
p1y = approx[0][0][1]
p2x = approx[1][0][0]
p2y = approx[1][0][1]
p3x = approx[2][0][0]
p3y = approx[2][0][1]
p4x = approx[3][0][0]
p4y = approx[3][0][1]
approx_sort =[[[p1x,p1y]],
       [[p2x,p2y]],
       [[p3x,p3y]],
       [[p4x,p4y]]]
approx_sort.sort()
tlx = approx_sort[0][0][0]
tly = approx_sort[0][0][1]
blx = approx_sort[1][0][0]
bly = approx_sort[1][0][1]
trx = approx_sort[2][0][0]
tryy = approx_sort[2][0][1]
brx = approx_sort[3][0][0]
bry = approx_sort[3][0][1]

approx_sorted = np.zeros((4, 2), dtype = "float32")
#left corner of imag is (0,0)
# notation is left up - right up - right down -left down 
approx_sorted[0] = (tlx,tly)    #min
approx_sorted[1] = (trx,tryy)   #max 
approx_sorted[2] = (brx,bry)   # x coordinate is greater
approx_sorted[3] = (blx,bly)   # x is less and y is more than rect[1]

wraped = get_dimensions(image_scaled3, approx_sorted)
wraped = cv2.resize(wraped, (900, 400), interpolation = cv2.INTER_AREA)
cv2.imshow('ORG55',wraped)

cv2.imshow('ORG',image_scaled2)
cv2.waitKey(0)    
cv2.destroyAllWindows()


#get quad through contours https://www.opencv-srf.com/2011/09/object-detection-tracking-using-contours.html
