import cv2
import numpy as np

def get_contour_areas(contours):
    # returns the areas of all contours as list
    all_areas = []
    for cnt in contours:
        area = cv2.contourArea(cnt)
        all_areas.append(area)
    return all_areas

def get_dimensions(imagetoconvert,rect):
    (tl, tr, br, bl) = rect
    #distance between two points is root((x1-x2^2) + (y1-y2^2))
    widthA = np.sqrt(((br[0] - bl[0]) ** 2) + ((br[1] - bl[1]) ** 2))
    widthB = np.sqrt(((tr[0] - tl[0]) ** 2) + ((tr[1] - tl[1]) ** 2))
    maxWidth = max(int(widthA), int(widthB))
    heightA = np.sqrt(((tr[0] - br[0]) ** 2) + ((tr[1] - br[1]) ** 2))
    heightB = np.sqrt(((tl[0] - bl[0]) ** 2) + ((tl[1] - bl[1]) ** 2))
    maxHeight = max(int(heightA), int(heightB))    
    dst = np.array([
        [0, 0],
        [maxWidth - 1, 0],
        [maxWidth - 1, maxHeight - 1],
        [0, maxHeight - 1]], dtype = "float32")
    M = cv2.getPerspectiveTransform(rect, dst)
    warped = cv2.warpPerspective(imagetoconvert, M, (maxWidth, maxHeight))
    return warped

#original --> scale --> gray --> thresh --> blur -->errode + dilate -->edge detection
original_image= cv2.imread('C:\\Users\\test\\Desktop\\skew.jpg')
image_scaled = cv2.resize(original_image, (900, 400), interpolation = cv2.INTER_AREA)
#image_scaled = original_image
image_scaled2 = image_scaled.copy()
image_scaled3 = image_scaled.copy()
gray = cv2.cvtColor(image_scaled,cv2.COLOR_BGR2GRAY)
ret,thresh = cv2.threshold(gray,16,255, cv2.THRESH_BINARY)
cv2.imshow('thresh',thresh)
blured_gray = cv2.bilateralFilter(thresh, 5, 150, 250)
kernel = np.ones((5,5), np.uint8)
erosion = cv2.erode(blured_gray, kernel, iterations = 1)
dilated = cv2.dilate(erosion, kernel, iterations = 1)
edged = cv2.Canny(dilated, 5, 250)

#detect broken contours and draw them --> do the whole process again
contours, hierarchy = cv2.findContours(edged, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
cv2.drawContours(image_scaled,contours,-1,(255,255,255), 4)
cv2.imshow('Broken Contours',image_scaled)

#img-->gray-->contour img -->edge detection -->contour
gray2 = cv2.cvtColor(image_scaled,cv2.COLOR_BGR2GRAY)
edged2 = cv2.Canny(gray2, 5, 255)
contours2, hierarchy = cv2.findContours(edged2, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

#sort this new contours
sorted_contours = sorted(contours2, key=cv2.contourArea, reverse=True)
cv2.drawContours(image_scaled2,sorted_contours,0,(0,255,0),3)
c=sorted_contours[0]

#get 4 random points from approx ==> 
approx_sort = cv2.approxPolyDP(c, 0.01*cv2.arcLength(c,True),True)
'''
p1x = approx[0][0][0]
p1y = approx[0][0][1]
p2x = approx[1][0][0]
p2y = approx[1][0][1]
p3x = approx[2][0][0]
p3y = approx[2][0][1]
p4x = approx[3][0][0]
p4y = approx[3][0][1]

cv2.circle(image_scaled2,(p1x,p1y), 3, (0,0,255), -1)
cv2.circle(image_scaled2,(p2x,p2y),3, (0,0,255), -1)
cv2.circle(image_scaled2,(p3x,p3y),3, (0,0,255), -1)
cv2.circle(image_scaled2,(p4x,p4y),3, (0,0,255), -1)
'''
'''
approx_sort =[[[p1x,p1y]],
       [[p2x,p2y]],
       [[p3x,p3y]],
       [[p4x,p4y]]]
'''
temp1x = approx_sort[0][0][0]
temp1y = approx_sort[0][0][1]
temp2x = approx_sort[1][0][0]
temp2y = approx_sort[1][0][1]
temp3x = approx_sort[2][0][0]
temp3y = approx_sort[2][0][1]
temp4x = approx_sort[3][0][0]
temp4y = approx_sort[3][0][1]
cv2.circle(image_scaled2,(temp1x,temp1y) , 3, (0,0,255), -1)
cv2.circle(image_scaled2,(temp2x,temp2y) ,3, (0,0,255), -1)
cv2.circle(image_scaled2,(temp3x,temp3y) ,3, (0,0,255), -1)
cv2.circle(image_scaled2,(temp4x,temp4y) ,3, (0,0,255), -1)
approx_sorted = np.zeros((4, 2), dtype = "float32")
rect = np.zeros((4, 2), dtype = "float32")
#left corner of imag is (0,0)
# notation is left up - right up - right down -left down 
approx_sorted[0] = (temp1x,temp1y)    #min
approx_sorted[1] = (temp2x,temp2y)   #max 
approx_sorted[2] = (temp3x,temp3y)   # x coordinate is greater
approx_sorted[3] = (temp4x,temp4y)   # x is less and y is more than rect[1]

s = approx_sorted.sum(axis = 1)
rect[0] = approx_sorted[np.argmin(s)]
rect[2] = approx_sorted[np.argmax(s)]

diff = np.diff(approx_sorted, axis = 1)
rect[1] = approx_sorted[np.argmin(diff)]
rect[3] = approx_sorted[np.argmax(diff)]


wraped = get_dimensions(image_scaled3, rect)
wraped = cv2.resize(wraped, (900, 400), interpolation = cv2.INTER_AREA)
cv2.imshow('Final',wraped)

cv2.imshow('ORG',image_scaled2)
cv2.waitKey(0)    
cv2.destroyAllWindows()


#get quad through contours https://www.opencv-srf.com/2011/09/object-detection-tracking-using-contours.html
